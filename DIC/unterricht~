Schieberegister:
----------------
Schieberegister sind Speicherschaltungen mit kettenförmig angeordneten getakten FlipFlops. Die Information wird wie in einem Register gespeichert, darüber 
hinaus lässt sich in einem Schieberegister die Information zwischen benachbarten FliFlopstufen verscoben. Der Takt steuert die Weitergabe der Information 
entlang der Speicherketten. 

(BILD1)

Der Eingang der ersten FlipFlopstufe ist gleichzeitig der serielle Eingang SE, und der Ausgang der letzen Stufe ist der serielle Ausgang SA. In dem 
Schieberegister besteht zwischen den benachbarten Gliedern eine Verbindung vom Ausgang zum Eingang der nächsten Stufe. Durch die Anordnung von Ausgang und 
Eingang in einer Kette wird die Schieberegisters ist die Schieberichtung "rechts".


Schieberegister mit VHDL:
-------------------------
Kurzbeschfreibung: Der Logikzustand am seriellen Eingang wird in das Schieberegister übernommen und mit jedem Takt wird der Inhalt des Schieberegisters um eine 
Stelle nach rechts geschoben:
Mit der seriellen Information q(0) -> q(1) -> q(2) -> q(3) einer Kette wird die Schieberichtung festgelegt.

	libary ieee;
	use ieee.std_logic_1164.all:

	entity srg is port(
		clk, reset, seriell: in std_logic;
		q: buffer std_logic_ector(0 to 3));
	end srg;
	
	architecture beh_reg of srg is
	begin
		schieben: process (clk,reset)
		begin
			if reset = '1' then q <= "0000";
			elseif(clk'event and clk = '1') then
				q(3) <= q(2);
				q(2) <= q(1);
				q(1) <= q(0);
				q(0) <= seriell;
			end if;
		end process schieben;
	end beh_reg;

Schieberegister sind in allen Bausteinfamilien als integrierte Bausteine vertreten. Exemplarisch sei hier das 8-Bit-Schieberegister 74LS91 aus der 
TTL-Schaltkreisfamilie erwähnt. Es hat folgende Eigenschaften:

(BILD 2)

Multiplexer und Depmultiplexer:
-------------------------------

In der Praxis ist es oft erforderlich, aus mehreren Übertragungskanälen einen auszuwählen und seine Dateninformation an ein anderes System durchzuschalten. Ein derartiges System wird Multiplexer oder Datenselektor genannt.

Beispiel: Entwurf eines 4-zu-1-Multiplexers

Soll von 4 Datenkanälen ein Kanal durchgeschalten werden, so sind ld4 = 2 Steuervariablen (A und B) erforderlich. In einer Wahrheitstabellee wird der Zusammenhang zwischen dem selektierten Datenkanal und der Bitkombination der Steuervariablen (Adresse) deutlich.

(BILD)

Zum Schaltsymbol:
Die Steuereingänge sind mit 0 und 1 gekennzeichnet. Dadurch wird die Wertigkeit der Eingänge festgelegt. G ist die Abkürzung für Gate (UND-Verknüpfung). Mit dieser Bezeichnung wird die Abhängigkeit der Dateneingänge von en Steuereingängen gekennzeichnet.

CODE:
-----

entity mux4_1 is port(
	adr:	in bit_vector(1 downto 0); --Steuereingaenge als 2-Bit-Vektor
	d1, d2, d3 ,d4: in bit;
	<: out bit);
end mux4_1;
architecture innenleben of mux4_1 is begin
	multiplexer: process (adr, d1, d2, d3, d4) begin --Aenderung von adr startet den Prozess
		case adr is
		when "00" => y <= d1;
		when "01" => y <= d2;
		when "10" => y <= d3;
		when "11" => y <= d4;
		end case;
	end process multiplexer;
end innenleben;

Demultiplexer:
--------------

Beim Demultiplexer wird in Abhängigkeit von der Schalterstellung eine Dateninformation an verschiedene Ausgänge verteilt.

Die Schalterstellung wird gekennzeichnet durch eine bestimmte Adresse, die über Steuervariablen vorgegeben wird. Soll die Dateninformation X an n Ausgängen verteilt werden, so sind ld n Steuervariablen erforderlich.

Beispiel: Entwurf eines 1-zu-4-Demultiplexers.
Es sind für die Verteilung an 4 Ausgängen 2 Steuervaribalen (A, B) erforderlich.

Zum Schaltsymbol:
-----------------

Die Steuereingänge sind mit 0 und 1 gekennzeichnet. Dadruch wird die Wertigkeit der Eingänge festgelegt. G ist die Abkürzung für Gate (UND-Verknüpfung). Mit dieser Bezeichnung wird die Abhängigkeit der Datenausgänge von den Steuereingängen gekennzeichnet.

CODE:
-----

entity dmux1_4 is port(
	adr: 	in bit_vector (1 downto 0); --Adresse des Datenkanals
	x: in bit; --Eingaenge
	y1, y2, y3, y4:		out bit); --Ausgaenge
end dmux1_4;
architecture innenleben of dmux1_4 is begin
	demultiplexer: process (adr,x) begin
		case adr is
			when "00" => y1 <= x; y2 <= '0'; y3 <= '0'; y4 <= '0';
			when "01" => y2 <= x; y1 <= '0'; y3 <= '0'; y4 <= '0';
			when "10" => y3 <= x; y1 <= '0'; y2 <= '0'; y4 <= '0';
			when "11" => y4 <= x; y1 <= '0'; y2 <= '0'; y3 <= '0';
		end case;
	end process demultiplexer;
end innenleben;

FLIP-FLOP:
----------

Das ungetaktete RS-FlipFlop ist das FlipFlop mit dem geringsten Schaltungsaufwand und lässt sich im einfachsten Fall mit Hilfe zweier NOR-Gatter realisieren. Es wird über den Setzeingang (S=1) gesetz und über den Rücksetzeingang (R=1) rückgesetzt. Für S=0 und R=0 speichert das FlipFlop den Logik-Zustand.

Es gilt folgende Zuordnung:
	RS-FlipFlop gesetzt:	Q=1 und Q(NICHT) = 0
	und rückgesetzt:	Q=0 und Q(NICHT) = 1

Beim Entwurf des RS-FlipFlop geht man davon aus, dass gleichzeitiges Setzen (S=1) und Rücksetzen (R=1) nicht sinnvoll ist und deshalb vom Anwender vermieden werden soll. Unter dieser Vorraussetzung ergibt sich für diese Kombination (S=1 und R = 1) ein redundanter Term, der bei der Minimierung der logischen Gleichung berücksichtigt wird. Dadurch erhält man eine besonders einfache Schaltung für das RS-FlipFlop.

CODE:
-----

libary ieee;
use ieee.std_logic_1164.all;

entity rs_ff is port(
	r,s: in std_logic;
	q: buffer std_logic);
end rs_ff;

architecture rs_verhalten of rs_ff is --Architektur fuer Verhaltensbeschreibung
begin
	process(r,s)
	begin
		if(S = '1' and r = '0') then --setzen
			q <= '1';
		elseif(s = '0' and r = '1') then --ruecksetzen
			q <= '0';
		elsif(s = '0' and r = '1') then --speichern
			q <= q;
		else




















